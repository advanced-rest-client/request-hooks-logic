<!doctype html>
<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../request-data-extractor.html">
  </head>
  <body>
    <script>
    /* global ActionIterableObject */
    suite('ActionIterableObject', () => {
      suite('constructor()', () => {
        let opts;
        setup(() => {
          opts = {
            operator: 'equal',
            condition: 'test',
            source: 'properties.*.first',
          };
        });

        test('Sets "source" as an array', () => {
          const instance = new ActionIterableObject(opts);
          assert.typeOf(instance.source, 'array');
          assert.lengthOf(instance.source, 3);
        });

        test('Sets operator', () => {
          const instance = new ActionIterableObject(opts);
          assert.equal(instance.operator, opts.operator);
        });

        test('Sets condition', () => {
          const instance = new ActionIterableObject(opts);
          assert.equal(instance.condition, opts.condition);
        });

        test('Won\'t set properties if not valid', () => {
          opts.operator = 'unknown';
          const instance = new ActionIterableObject(opts);
          assert.isUndefined(instance.source);
          assert.isUndefined(instance.operator);
          assert.isUndefined(instance.condition);
        });
      });

      suite('_validate()', () => {
        let opts;
        let instance;
        setup(() => {
          opts = {
            operator: 'equal',
            condition: 'test',
            source: 'properties.*.first'
          };
          instance = new ActionIterableObject(opts);
        });

        test('Returns true for valid options', () => {
          const result = instance._validate(opts);
          assert.isTrue(result);
        });

        test('Returns false when no source', () => {
          delete opts.source;
          const result = instance._validate(opts);
          assert.isFalse(result);
        });

        test('Returns false when no operator', () => {
          delete opts.operator;
          const result = instance._validate(opts);
          assert.isFalse(result);
        });

        test('Returns false when no condition', () => {
          delete opts.condition;
          const result = instance._validate(opts);
          assert.isFalse(result);
        });

        test('Returns false when operator is not known', () => {
          opts.operator = 'test';
          const result = instance._validate(opts);
          assert.isFalse(result);
        });

        [
          'equal', 'not-equal', 'greater-than', 'greater-than-equal',
          'less-than', 'less-than-equal', 'contains', 'regex'
        ].forEach((op) => {
          test('Returns true when operator is ' + op, () => {
            opts.operator = op;
            const result = instance._validate(opts);
            assert.isTrue(result);
          });
        });
      });
    });

    /* global JsonExtractor */
    suite('JsonExtractor', () => {
      const json = '{"test": true}';
      const path = 'a.b.b';
      const iterator = {
        operator: 'equal',
        condition: 'test',
        source: 'properties.*.first'
      };
      suite('Constructor', () => {
        test('Sets _data property', () => {
          const instance = new JsonExtractor(json, path, iterator);
          assert.typeOf(instance._data, 'object');
        });

        test('Sets _path property when set', () => {
          const instance = new JsonExtractor(json, path, iterator);
          assert.typeOf(instance._path, 'array');
          assert.lengthOf(instance._path, 3);
        });

        test('_path is undefined when missing', () => {
          const instance = new JsonExtractor(json, undefined, iterator);
          assert.isUndefined(instance._path);
        });

        test('Sets _iterator property', () => {
          const instance = new JsonExtractor(json, path, iterator);
          assert.isTrue(instance._iterator instanceof ActionIterableObject);
        });
      });

      suite('_processJson()', () => {
        test('Returns undefined when no argument', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson();
          assert.isUndefined(result);
        });

        test('Returns undefined when argument is a number', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson(5);
          assert.isUndefined(result);
        });

        test('Returns undefined when argument is a boolean', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson(true);
          assert.isUndefined(result);
        });

        test('Returns undefined when argument cannot be parsed', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson('{"test');
          assert.isUndefined(result);
        });

        test('Returns passed argument if not string', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson({test: 'value'});
          assert.deepEqual(result, {test: 'value'});
        });

        test('Returns object', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson(json);
          assert.deepEqual(result, {
            test: true
          });
        });

        test('Returns array', () => {
          const instance = new JsonExtractor(json, path, iterator);
          const result = instance._processJson('["a"]');
          assert.deepEqual(result, ['a']);
        });
      });

      suite('extract()', () => {
        suite('Object json', function() {
          const json = `
          {
            "items": [{
              "id": "id1",
              "name": {
                "first": "Test"
              }
            }, {
              "id": "id2",
              "name": {
                "first": "Brown"
              }
            }],
            "nextPageToken": "testToken",
            "deep": {
              "object": {
                "value": "true"
              }
            }
          }
          `;
          let extractor;
          test('Reads first level value', function() {
            extractor = new JsonExtractor(json, 'nextPageToken');
            const result = extractor.extract();
            assert.equal(result, 'testToken');
          });

          test('Reads deep object value', function() {
            extractor = new JsonExtractor(json, 'deep.object.value');
            const result = extractor.extract();
            assert.equal(result, 'true');
          });

          test('Reads array value', function() {
            extractor = new JsonExtractor(json, 'items.1.id');
            const result = extractor.extract();
            assert.equal(result, 'id2');
          });

          test('Reads array deep value', function() {
            extractor = new JsonExtractor(json, 'items.1.name.first');
            const result = extractor.extract();
            assert.equal(result, 'Brown');
          });

          test('Returns undefined for unknown path', function() {
            extractor = new JsonExtractor(json, 'items.2.name.first');
            const result = extractor.extract();
            assert.isUndefined(result);
          });

          test('Returns undefined for unknown json', function() {
            extractor = new JsonExtractor(undefined, 'items.2.name.first');
            const result = extractor.extract();
            assert.isUndefined(result, 'Brown');
          });
        });

        suite('Array JSON', function() {
          const json = [{
            id: 'id1',
            name: {
              first: 'Test',
              last: 'Name'
            }
          }, {
            id: 'id2',
            name: {
              first: 'Brown',
              last: 'test2'
            }
          }];
          let extractor;
          test('Reads array value without iterator', function() {
            extractor = new JsonExtractor(json, '0.id');
            const result = extractor.extract();
            assert.equal(result, 'id1');
          });

          test('Reads deep array value without iterator', function() {
            extractor = new JsonExtractor(json, '0.name.first');
            const result = extractor.extract();
            assert.equal(result, 'Test');
          });

          test('Returns undefined when path not found', function() {
            extractor = new JsonExtractor(json, '0.name.something');
            const result = extractor.extract();
            assert.isUndefined(result);
          });
        });
      });
    });

    suite('Iterators', function() {
      suite('Object value', function() {
        const json = `
        {
          "items": [{
            "id": "id1",
            "name": {
              "first": "Test",
              "last": "Last test"
            }
          }, {
            "id": "id2",
            "name": {
              "first": "Adam",
              "last": "Brown"
            }
          }]
        }
        `;
        const iterator = {
          source: 'items.*.name.last',
          operator: 'equal',
          condition: 'Brown'
        };
        let extractor;
        test('Reads iterable value', function() {
          extractor = new JsonExtractor(json, 'id', iterator);
          const result = extractor.extract();
          assert.equal(result, 'id2');
        });

        test('Reads iterable deep value', function() {
          extractor = new JsonExtractor(json, 'name.first', iterator);
          const result = extractor.extract();
          assert.equal(result, 'Adam');
        });
      });

      suite('Array value', function() {
        const json = [{
          id: 'id1',
          name: {
            first: 'Test',
            last: 'Name'
          }
        }, {
          id: 'id2',
          name: {
            first: 'Brown',
            last: 'test2'
          }
        }];
        const iterator = {
          source: '*.name.first',
          operator: 'equal',
          condition: 'Brown'
        };
        let extractor;
        test('Reads simple path value', function() {
          extractor = new JsonExtractor(json, 'id', iterator);
          const result = extractor.extract();
          assert.equal(result, 'id2');
        });

        test('Reads deep path value', function() {
          extractor = new JsonExtractor(json, 'name.last', iterator);
          const result = extractor.extract();
          assert.equal(result, 'test2');
        });
      });

      suite('Iteration over objects', function() {
        const json = {
          id: 'id1',
          properties: {
            first: 'Test',
            last: 'Name',
            id: 'testid'
          },
          deep: {
            value: {
              properties: {
                first: 'Test',
                last: 'Name',
                id: 'testid2'
              }
            }
          }
        };
        const iterator = {
          source: 'properties.*.first',
          operator: 'equal',
          condition: 'Test'
        };
        let extractor;
        test('Reads simple path value', function() {
          extractor = new JsonExtractor(json, 'id', iterator);
          const result = extractor.extract();
          assert.equal(result, 'testid');
        });

        test('Reads simple path value', function() {
          iterator.source = 'deep.value.properties.*.first';
          extractor = new JsonExtractor(json, 'id', iterator);
          const result = extractor.extract();
          assert.equal(result, 'testid2');
        });
      });
    });
    </script>
  </body>
</html>
