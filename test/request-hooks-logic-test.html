<!doctype html>
<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../jexl/jexl.html">
    <link rel="import" href="../request-hooks-logic.html">
  </head>
  <body>
    <test-fixture id="Basic">
      <template>
        <request-hooks-logic></request-hooks-logic>
      </template>
    </test-fixture>

    <script>
    suite('get evalElement()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns variables-evaluator element', () => {
        const result = element.evalElement;
        assert.equal(result.nodeName, 'VARIABLES-EVALUATOR');
      });

      test('Inserts element into the DOM', () => {
        const result = element.evalElement;
        assert.ok(result);
        const node = element.shadowRoot.querySelector('variables-evaluator');
        assert.equal(node.nodeName, 'VARIABLES-EVALUATOR');
      });

      test('Eval has noBeforeRequest property', () => {
        const result = element.evalElement;
        assert.isTrue(result.noBeforeRequest);
      });

      test('Eval has eventTarget property', () => {
        const result = element.evalElement;
        assert.isTrue(result.eventTarget === element);
      });

      test('Returns the same element', () => {
        const result1 = element.evalElement;
        const result2 = element.evalElement;
        assert.isTrue(result1 === result2);
      });
    });

    suite('processActions()', () => {
      let element;
      let actions;
      let request;
      let response;
      setup(() => {
        element = fixture('Basic');
        actions = [{
          source: 'request.url',
          action: 'assign-variable',
          destination: 'req-url'
        }, {
          source: 'response.url',
          action: 'assign-variable',
          destination: 'res-url'
        }];
        request = {
          method: 'GET',
          url: 'http://request'
        };
        response = {
          url: 'http://response'
        };
      });

      test('Rejects when no actions argument', () => {
        return element.processActions(undefined, request, response)
        .then(() => {
          throw new Error('Should not resolve');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Expecting 3 arguments.');
        });
      });

      test('Rejects when no request argument', () => {
        return element.processActions(actions, undefined, response)
        .then(() => {
          throw new Error('Should not resolve');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Expecting 3 arguments.');
        });
      });

      test('Rejects when no response argument', () => {
        return element.processActions(actions, request, undefined)
        .then(() => {
          throw new Error('Should not resolve');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Expecting 3 arguments.');
        });
      });

      test('Resolves the promise', () => {
        return element.processActions(actions, request, response);
      });

      test('Calls _evaluateAction() for each action', () => {
        const spy = sinon.spy(element, '_evaluateAction');
        return element.processActions(actions, request, response)
        .then(() => {
          assert.equal(spy.callCount, 2);
        });
      });

      test('Ignores disabled actions', () => {
        actions[0].enabled = false;
        const spy = sinon.spy(element, '_evaluateAction');
        return element.processActions(actions, request, response)
        .then(() => {
          assert.equal(spy.callCount, 1);
        });
      });

      test('Calls _runRecursive() for each action + 1 (when stopping)', () => {
        const spy = sinon.spy(element, '_runRecursive');
        return element.processActions(actions, request, response)
        .then(() => {
          assert.equal(spy.callCount, 3);
        });
      });
    });

    suite('_evaluateAction()', () => {
      let element;
      let actions;
      setup(() => {
        element = fixture('Basic');
        actions = [{
          source: 'request.${sourceVar}',
          action: '${actionVar}',
          destination: 'req-url-${destVar}'
        }, {
          source: 'response.url',
          action: 'assign-variable',
          destination: 'res-url',
          iterator: {
            source: 'items.${sourceVar}',
            operator: '${opVar}',
            condition: 'cond-${condVar}'
          }
        }];
      });

      test('Calls _copyAction()', () => {
        const spy = sinon.spy(element, '_copyAction');
        return element._evaluateAction(actions[0])
        .then(() => {
          assert.equal(spy.callCount, 1);
        });
      });

      test('Evaluates action\'s source property', () => {
        return element._evaluateAction(actions[0])
        .then((action) => {
          assert.equal(action.source, 'request.undefined');
        });
      });

      test('Evaluates action\'s destination property', () => {
        return element._evaluateAction(actions[0])
        .then((action) => {
          assert.equal(action.destination, 'req-url-undefined');
        });
      });

      test('Skips action\'s action property', () => {
        return element._evaluateAction(actions[0])
        .then((action) => {
          assert.equal(action.action, '${actionVar}');
        });
      });

      test('Evaluates iterator\'s source property', () => {
        return element._evaluateAction(actions[1])
        .then((action) => {
          assert.equal(action.iterator.source, 'items.undefined');
        });
      });

      test('Evaluates iterator\'s condition property', () => {
        return element._evaluateAction(actions[1])
        .then((action) => {
          assert.equal(action.iterator.condition, 'cond-undefined');
        });
      });

      test('Skips iterator\'s operator property', () => {
        return element._evaluateAction(actions[1])
        .then((action) => {
          assert.equal(action.iterator.operator, '${opVar}');
        });
      });
    });

    suite('_copyAction()', () => {
      let element;
      let action;
      setup(() => {
        element = fixture('Basic');
        action = {
          source: 'response.url',
          action: 'assign-variable',
          destination: 'res-url',
          iterator: {
            source: 'items.${sourceVar}',
            operator: '${opVar}',
            condition: 'cond-${condVar}'
          },
          conditions: [{
            enabled: true,
            source: 'response.status',
            operator: 'equal',
            condition: '200'
          }]
        };
      });

      test('Creates a copy of the main object', () => {
        const result = element._copyAction(action);
        const origValue = action.source;
        action.source = 'test';
        assert.equal(result.source, origValue);
      });

      test('Creates a copy of the iterator', () => {
        const result = element._copyAction(action);
        const origValue = action.iterator.source;
        action.iterator.source = 'test';
        assert.equal(result.iterator.source, origValue);
      });

      test('Creates a copy of the condition', () => {
        const result = element._copyAction(action);
        const origValue = action.conditions[0].source;
        action.conditions[0].source = 'test';
        assert.equal(result.conditions[0].source, origValue);
      });
    });

    suite('_createLogicElement()', () => {
      let element;
      let action;
      setup(() => {
        element = fixture('Basic');
        action = {
          source: 'response.url',
          action: 'assign-variable',
          destination: 'res-url',
          hasIterator: true,
          iterator: {
            source: 'items.${sourceVar}',
            operator: '${opVar}',
            condition: 'cond-${condVar}'
          },
          conditions: [{
            enabled: true,
            source: 'response.status',
            operator: 'equal',
            condition: '200'
          }]
        };
      });

      test('Returns instance of the element', () => {
        const result = element._createLogicElement(action);
        assert.equal(result.nodeName, 'REQUEST-LOGIC-ACTION');
      });

      test('Inserts element into the shadow DOM', () => {
        element._createLogicElement(action);
        const node = element.shadowRoot.querySelector('request-logic-action');
        assert.equal(node.nodeName, 'REQUEST-LOGIC-ACTION');
      });

      test('Sets source property', () => {
        const result = element._createLogicElement(action);
        assert.equal(result.source, action.source);
      });

      test('Sets action property', () => {
        const result = element._createLogicElement(action);
        assert.equal(result.action, action.action);
      });

      test('Sets destination property', () => {
        const result = element._createLogicElement(action);
        assert.equal(result.destination, action.destination);
      });

      test('Sets conditions property', () => {
        const result = element._createLogicElement(action);
        assert.deepEqual(result.conditions, action.conditions);
      });

      test('Sets iterator property', () => {
        const result = element._createLogicElement(action);
        assert.deepEqual(result.iterator, action.iterator);
      });

      test('Sets iteratorEnabled property', () => {
        const result = element._createLogicElement(action);
        assert.equal(result.iteratorEnabled, action.hasIterator);
      });
    });

    suite('run-response-actions event', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      function fire(actions, request, response) {
        const e = new CustomEvent('run-response-actions', {
          bubbles: true,
          cancelable: true,
          detail: {
            actions,
            request,
            response
          }
        });
        document.body.dispatchEvent(e);
        return e;
      }

      test('Event is not handled when cancelled', () => {
        document.body.addEventListener('run-response-actions', function f(e) {
          document.body.removeEventListener('run-response-actions', f);
          e.preventDefault();
        });
        const e = fire([], {}, {});
        assert.isUndefined(e.detail.result);
      });

      test('Event is handled', () => {
        const e = fire([], {}, {});
        assert.typeOf(e.detail.result.then, 'function');
      });

      test('Calls processActions()', () => {
        const spy = sinon.spy(element, 'processActions');
        fire([], {}, {});
        assert.isTrue(spy.called);
      });

      test('Result is rejected when no arguments', () => {
        const e = fire([], {});
        return e.detail.result
        .then(() => {
          throw new Error('Should not resolve');
        })
        .catch((cause) => {
          assert.equal(cause.message, 'Expecting 3 arguments.');
        });
      });
    });
    </script>
  </body>
</html>
